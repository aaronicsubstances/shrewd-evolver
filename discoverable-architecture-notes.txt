# Discoverable database schema
-DB vendor independent way to specify relationships (cardinality, ordinality at each end)
-foreign keys?
-constraints (the C in ACID). Defining primitives to use - pure functional expressions to apply to subset of records in all tables.
-probably think of something like running checks and tests on database readonly view (snapshot isolation sort of)

GREAT! Let discoverable database schema take the form of tests on database, probably random portions of it rather than all.
Hopefully, because they are tests, future maintainers can read and understand.

# Discoverable software architecture based on network connections

-Log network connections and run checks and tests on them to assert some architectural constraints on which subsystems can talk to who.
-Also useful could be discovering subsystem connectivity or network from network connection log

Will need to use Wireshark for such discovery. As such subsystem network communication must use well known network protocols
As such, need communication patterns with these characteristics:
 - every subsystem needs to be identified by a socket address - IP and TCP/UDP port
 - HTTP or look-alike (based on multiplexed TCP or UDP) for synchronous communications (aka "www for computer agents").
 - SMTP/IMAP or look-alike (based on multiplexed TCP or UDP) for asynchronous communication (aka "email for computer agents").
 - DNS and LDAP for domain name translation and other directory services
 - Proxies and protocol translators for above mentioned protocols at application layer as needed.

PseudoHTTP
----------
 - based on HTTP/1.0 (https://www.w3.org/Protocols/HTTP/1.0/spec.html)
 - parsing rules based on HTTP/1.1 (https://datatracker.ietf.org/doc/html/rfc7230)
 - 4 verbs: GET, POST, PUT, DELETE
 - no 1xx status codes
 - hence never send Expect request header to HTTP/1.1 server
 - the only acceptable value for transfer encoding response header is "chunked"
 - hence never send TE request header to HTTP/1.1 server
 - always assume Connection: close present in response headers
 - no content encoding (always use Accept-Encoding: identity request header)
 - no automatic redirects

Promising PseudoHttp Client Library Support
---------------------------------------
Python - aiohttp over unix domain socket extension
PHP - reactphp http over unix domain socket extension
Java - use Netty http codecs
NodeJS - looks like desire for isomorphic http client library is prevalant,
 reducing incentive for NodeJS-only http clients.
C#.NET Core - Use .NET Core 5 SocketsHttpHandler Extension Points
Ruby - Faraday with custom adapter, HttParty with custom ConnectionAdaptor

PseudoHttp Server Framework Support
-----------------------------
Python - WSGI
C#.NET Core - OWIN
Ruby - Rack
Java - Servlet Container. Undertow.io looks like what will fit our purpose, 
 - by writing custom listeners and handlers, and handling async I/O.
NodeJS - Effectively http.createServer(app). where app is the framework (e.g. ExpressJs).
 - Basically mimick http module. And then when http.createServer(app) is called,
 - our internal logic kicks in. Example: https://www.npmjs.com/package/node-fastcgi
PHP - ReactPHP HTTP

PseudoEmail
------------
Pub sub, Mini kafka, can support 4 types of Rx subjects
3 parts: pubsubcore, external producer, external consumer

external producer:
A. generate topic (regular or compact)
B. generate message (topic, msg id, value, key, deleted, date created)

external consumer role: have an id?
A. save topic, id? and offset to disk (for no more than once) or memory (for at least once)
B. query with topic, offset and limit, boolean to include offset (msg id and date created combination as string). 
use null offset to fetch messages from the beginning.
C. query result is msg id, value, key, date created

pubsubcore/msmq
A. Clear regular topic messages with expiration timeout or storage capacity
B. Compact messages by deletion. Can be done concurrently as long as deletions of tombstones are done 
in transaction with latest version of corresponding message. Outdated message versions can always be
deleted.

Extra points
A. Simple design based on polling. Poll as long as messages are present. Else sleep for configurable 1 minute.
B. It is consumer's responsibility to suscribe/unsuscribe from msmq
C. msmq notifies consumers to poll, rather than with data, unless notifications are not being saved, in 
which case consumer does not care about previous or lost events.

