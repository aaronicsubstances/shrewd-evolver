# Discoverable database schema
-DB vendor independent way to specify relationships (cardinality, ordinality at each end)
-foreign keys?
-constraints (the C in ACID). Defining primitives to use - pure functional expressions to apply to subset of records in all tables.
-probably think of something like running checks and tests on database readonly view (snapshot isolation sort of)

GREAT! Let discoverable database schema take the form of tests on database, probably random portions of it rather than all.
Hopefully, because they are tests, future maintainers can read and understand.

# Discoverable software architecture based on network connections

-Log network connections and run checks and tests on them to assert some architectural constraints on which subsystems can talk to who.
-Also useful could be discovering subsystem connectivity or network from network connection log

Will need to use Wireshark for such discovery. As such subsystem network communication must use well known network protocols
As such, need communication patterns with these characteristics:
 - every subsystem needs to be identified by a socket address - IP and TCP/UDP port
 - HTTP or look-alike (based on multiplexed TCP or UDP) for synchronous communications (aka "www for computer agents").
 - SMTP/IMAP or look-alike (based on multiplexed TCP or UDP) for asynchronous communication (aka "email for computer agents").
 - DNS and LDAP for domain name translation and other directory services
 - Proxies and protocol translators for above mentioned protocols at application layer as needed.

PseudoHTTP
----------
 - based on HTTP/1.0 (https://www.w3.org/Protocols/HTTP/1.0/spec.html)
 - parsing rules based on HTTP/1.1 (https://datatracker.ietf.org/doc/html/rfc7230)
 - 4 verbs: GET, POST, PUT, DELETE
 - no 1xx status codes
 - hence never send Expect request header to HTTP/1.1 server
 - the only acceptable value for transfer encoding response header is "chunked"
 - hence never send TE request header to HTTP/1.1 server
 - always assume Connection: close present in response headers
 - no content encoding (always use Accept-Encoding: identity request header)
 - no automatic redirects

Promising PseudoHttp Client Library Support
---------------------------------------
Python - aiohttp over unix domain socket extension
PHP - reactphp http over unix domain socket extension
Java - use Netty http codecs
NodeJS - looks like desire for isomorphic http client library is prevalant,
 reducing incentive for NodeJS-only http clients.
C#.NET Core - Use .NET Core 5 SocketsHttpHandler Extension Points
Ruby - Faraday with custom adapter, HttParty with custom ConnectionAdaptor

PseudoHttp Server Framework Support
-----------------------------
Python - WSGI
C#.NET Core - OWIN
Ruby - Rack
Java - Servlet Container. Undertow.io looks like what will fit our purpose, 
 - by writing custom listeners and handlers, and handling async I/O.
NodeJS - Effectively http.createServer(app). where app is the framework (e.g. ExpressJs).
 - Basically mimick http module. And then when http.createServer(app) is called,
 - our internal logic kicks in. Example: https://www.npmjs.com/package/node-fastcgi
PHP - ReactPHP HTTP
