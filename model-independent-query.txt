## Model-Independent Query Support

Assume use of SQLite, or Temporary Table mechanism supported by mainstream RDBMSes for model independent query support.
Make it easy to import large datasets into temporary SQLite databases or temporary tables, and manages automatic
deletion of such objects after some timeouts.
May have to deal with expectation of schema by RDBMSes, by dealing with issues like
  - automatically identifiying column types (and even names) in result sets of queries
  - creating temporary tables based on schema suggested by column types to store such query results
  - loading data from such temporary tables into typed record list
  - transforming data in such temporary tables and mapping the results into typed record list as query results or as data to store in main RDBMS tables.

Implementation
--------------
1. delete temporary tables and files after some time - same need to evict append-only log events in memory or disk after processing
2. take advantage of views, materialized views, and as a last resort, insert into ... select
-in sql, we can create regular or temporary tables directly from query results
-in sqlite, we can leverage ephemeral file storage and dynamically-typed columns to have a template database file with precreated tables, which can be cloned and populated with query results.
3. Implement function for converting between trees and record list so as to extend model-independent querying to non-RDBMSes.
 - split into mapping record list into tuples of classes and using Reactive Extensions (Rx) and morelinq (using groupByAdjacent) libraries to map tuples of classes to trees
 - main job then is about mapping sql table/result set to list/tuple of field sets. That a list of field collection, where each collection doesn't duplicate field names,
   but a name may be present in two or more collections. So given a row like [{name:A, value:1}, {name:B, value:2}, {name:A, value: 0}], and a list of field sets like
   [class C1 {A,B}, class C2 {A}], the row should be mapped to something like [new C1(A=1,B=2), new C2(A=0)].
4. Implement function for loading targets of many to many relationships, given id, for non-RDBMSes.
 - implement efficiently in document db, sql or graph db using knowledge of all distinct ordered ids 
   whose targets are to be loaded. By have many to many table sorted by source ids, fetch target ids, and use WHERE id in (target ids)

