Develop best practices for working with ERD of property-graph model that supports abstraction of things like
- ACID transactions - this will work best with database technologies in which strings can be used to do everything from DDL
  to DML, ie like SQL. In that case a transaction coordinator can be in a separate process from its clients (transaction
  coordinator will nevertheless have to be the only one who can create and store transaction handles,
  and lease them out by GUID reference).
- SQL joins
- adding/deleting relationships
- loading, adding, updating or deleting single row using primary key (simple or composite)
- names of tables, table columns, views, functions, stored procedures and query result columns used in SQL builders
  - not required for dynamically typed languages
  - attempting to leverage static typing is a hard CS problem, and requires code generation

*Can make use of SQL scripts for almost static SQL (notably this works for NoSQL too)
 - for static sql, use strategy of storing SQL in file scripts, which can be tested independently of the program against the database
 by a quality assurance tool
 - for dynamic sql with a small number of possible variations (e.g. max of 10), store common SQL in file script and define the variations in terms
 of diff patches to the common script. Then let independent QA tool test each variation against database.
 - can use code generation to generate result set row class, or tuple of classes, by annotating result columns and their data types in the SQL scripts.

*Can make use of libraries for SQL builders available in every major web programming language (notably this works for NoSQL too)
 - especially for very dynamic SQL, that is, SQL statements with a large number of variations (e.g. more than 20).
 - only when SQL statement requires native features unsupported by particular SQL builder library AND is very dynamic, do we HAVE TO generate SQL
   without builders and also forego the ability to independently test.

learn from the following before attempting to implement ORMs
- https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/
- https://scala-slick.org/doc/3.0.0/orm-to-slick.html
- https://rdo.devzest.com
- https://www.datanucleus.org/products/accessplatform_4_2/jdo/metadata_api.html
- https://www.datanucleus.org/products/accessplatform_4_2/jdo/metadata_xml.html
- https://openjpa.apache.org/builds/1.2.3/apache-openjpa/docs/jpa_langref.html
- https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html
- https://docs.oracle.com/javaee/7/api/javax/persistence/metamodel/package-summary.html
- https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/package-summary.html
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html
- https://github.com/querydsl/querydsl (looks like JPA Criteria API makes it easier than JDOQL API to throw in native SQL)
